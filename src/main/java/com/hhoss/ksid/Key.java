package com.hhoss.ksid;

import java.util.Arrays;
import java.util.Date;

import com.hhoss.date.Formatter;
import com.hhoss.jour.Logger;
import com.hhoss.util.Random;

/**
 * return global unique 50W sequence in every second
 * will wait to next second if need more
 * @author kejun
 * <pre>{@code 
 * +------+---------------++----------+-------+-------+----------+
 * | sign | delta seconds || sequence | mold  | site  | worker   |
 * +------+---------------++----------+-------+-------+----------+
 *   1bit      31bits         13bits    6bits   6bits    7bits
 * }</pre>
 *
 */
public class Key {	
	private static final Logger logger = Logger.get();    
	private static final int BITS = 19;
	private static final int MASK = ~(-1<<BITS);//(1<<BITS)-1;
	
	private static final int bits = 13;
	private static final int mask = ~(-1<<bits);//(1<<bits)-1;
	private static final int work = Idsn.appCode4()&mask;//site+worker
	private static long tims = 0;//Tims.get();
	private static int loop = 0;
	private static int head = loop;

	
	/**
	 *  bulk keys with special amount size
	 * @param size
	 * @return long[] of keys with special amount size
	 */
	public static long[] get(int size) {
		long[] keys = new long[size];
		for(int i=0;i<size;i++) {
			keys[i]=next();
		}
		return keys;
	}
	
    /**
     * <br/>返回19位长度的序列号，在每个应用实例的保证唯一性，
     * <br/>日期(14bit)+时间(17bit)+序列号6位(19bit)+应用实例4位(13bit)
     * <br/>单应用（运行实例数最大8000）支持每秒50万的序列号全局30年不重复；
     * <br/>序列生成时间大约0.1us；
     * <br/>bits usage rate about 48%: 12/16 * 31/32 * 24/32 * 60/64 * 60/64
     * @return next sequence for global 
     * @see {@link Tims#get()}

     */
    public synchronized final static long next(){
    	int[] meta = Tims.meta();
      	long inst = Tims.from(meta);//31位到秒；
    	if( tims > inst ){
    		logger.error("system clock error, old[{}] is after now[{}].",tims,inst);
    		throw new IllegalArgumentException("system clock error!");
    	}
      	loop = (loop+1) & MASK;
    	if( tims < inst ){
    		//logger.debug("tims:{}->{},seq:{}->0.",tims,inst,seq);
    		//if(monofonic){loop=0;} else
    		reset();
    	}else if( head == loop ){//wait to next time
     		logger.debug("cyclic too fast, wait to next second; now:{}",tims);
     		int i=1;
    		while(inst<=tims)try{
    			logger.debug("{} sleeps: {} ms",i++,1000-meta[7]);
    			Thread.sleep(1000-meta[7]);
    			//Thread.sleep(20);
    			meta = Tims.meta();
    			inst=Tims.from(meta);
    		}catch(Exception e){}
    		reset();
      	}
    	tims=inst;
    	return tims<<32 | (long)loop<<bits | work ;
    }
    
    private static void reset() {
    	loop = Random.get(1<<(BITS-3));//avoid waiting caused by arrive bound.
    	head = loop;
    }
     
    /**
     * @return Long.toString 
     * @see #next()
     */
    public static String text(){
    	return Long.toString(next());
    }
    
   /**
     * key next long encode to capital letter and numbers,best for readable.
     * @return
    * @see  {@link #next()}
    * @see  CapNum#encode(long)
     */
    public static String code(){
    	return CapNum.encode(next());
    }
    
    /**
     * 如果增加校验位，建议使用定长，这样输出位数14位，在位数不够的时候不易造成可读性混淆。
     * @param num
     * @param prefix 是否定长，保前缀占位符
     * @param subfix 是否末尾增加后缀校验位
     * @return string of encodes
     * @see  CapNum#encode(long, boolean, boolean)
     */
    public static String code(long num, boolean prefix, boolean subfix) {
    	return CapNum.encode(num,prefix, subfix);
    }
    /**
     * @param str the encoded codes
     * @return boolean, true if passed the RCPC checks
     * @see CapNum#check(String)
     */
    public static boolean check(String str) {
    	return CapNum.check(str);
    }   
    
	/**
	 * @param str the encode string
	 * @param suffix 最后一位是否为校验位
	 * @return the num as long, 0 if wrong 
	 */
    public static long code(String str, boolean subfix) {
    	return CapNum.decode(str, subfix);
    }
    /**
     * generate new key using Key.next()
     * @return  int[9]{y,yyyy,M,d,h,m,s,seq,loc} 
     */
    public static int[] meta(){    	
    	return meta(next());
    }

    /**
     * @param lsn long generated by {@link Key#next()} or {@link Key#text()};
     * @return int[9]{y,yyyy,M,d,h,m,s,seq,loc} 
     */
    public static int[] meta(long lsn){    	
    	int[] flds = Tims.meta((int)(lsn>>>32));    	
			  flds = Arrays.copyOf(flds, 9);
 			  flds[7]= ((int)lsn)>>>bits; // cyclic Seq;
    		  flds[8]= mask&(int)(lsn); //worker;
    	return flds;
    }  
    
     /**
     * @param lsn long generated by {@link Key#next()} or {@link Key#text()};
     * @return yyyyMM
     */
    public static String yyyyMM(long lsn){
       	return Formatter.format(new Date((lsn>>>32)*1000),"yyyyMM");
    }
   /**
     * @param lsn long generated by {@link Key#next()} or {@link Key#text()};
     * @return yyyyMMdd
     */
    public static String yyyyMMdd(long lsn){
    	return Formatter.format(new Date((lsn>>>32)*1000),"yyyyMMdd");
    }
    /**
     * @param lsn long generated by {@link Key#next()} or {@link Key#text()};
     * @return yyMMdd
     */
    public static String yyMMdd(long lsn){
    	return Formatter.format(new Date((lsn>>>32)*1000),"yyMMdd");
    }    
    

}
